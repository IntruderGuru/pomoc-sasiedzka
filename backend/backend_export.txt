=== ŚCIEŻKA ===
.env
=== ZAWARTOŚĆ ===
DB_HOST=localhost
DB_PORT=5434
DB_USER=postgres
DB_PASSWORD=''root''
DB_NAME=somsiad
JWT_SECRET=jakisSekretnyKlucz
JWT_EXPIRES_IN=1h

=== ŚCIEŻKA ===
package.json
=== ZAWARTOŚĆ ===
{
    "name": "backend",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
        "dev": "nodemon -L src/index.ts",
        "build": "tsc",
        "start": "node dist/index.js",
        "postgres:setup": "docker pull postgres && docker rm -f somsiad-db && docker run -d --name somsiad-db -p 5434:5432 -e POSTGRES_DB=somsiad -e POSTGRES_PASSWORD='root' postgres",
        "postgres:migrate": "tsx src/database/migrate.ts",
        "postgres:psql": "docker exec -it somsiad-db psql -U postgres",
        "postgres:dump": "docker exec -it somsiad-db pg_dump -U postgres -h localhost -p 5432 somsiad > src/database/sql_dumps/dump-somsiad.sql",
        "test": "vitest",
        "lint": "eslint src && tsc --noEmit",
        "lint:fix": "eslint --fix src && tsc --noEmit",
        "format": "prettier -w src"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "description": "",
    "dependencies": {
        "bcrypt": "^5.1.0",
        "cors": "^2.8.5",
        "dotenv": "^16.4.7",
        "express": "^4.21.2",
        "jsonwebtoken": "^9.0.2",
        "kysely": "^0.27.6",
        "morgan": "^1.10.0",
        "pg": "^8.14.1"
    },
    "devDependencies": {
        "@eslint/js": "^9.25.1",
        "@types/bcrypt": "^5.0.0",
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.21",
        "@types/jsonwebtoken": "^8.5.9",
        "@types/morgan": "^1.9.9",
        "@types/node": "^22.13.14",
        "@types/pg": "^8.11.11",
        "eslint": "^9.25.1",
        "eslint-config-prettier": "^10.1.2",
        "eslint-plugin-prettier": "^5.2.6",
        "eslint-plugin-simple-import-sort": "^12.1.1",
        "globals": "^16.0.0",
        "kysely-migration-cli": "^0.4.2",
        "nodemon": "^3.1.9",
        "prettier": "^3.5.3",
        "ts-node": "^10.9.2",
        "tsx": "^4.19.3",
        "typescript": "^5.8.2",
        "typescript-eslint": "^8.31.0",
        "vitest": "^3.1.2"
    }
}


=== ŚCIEŻKA ===
tsconfig.json
=== ZAWARTOŚĆ ===
{
    "compilerOptions": {
        "target": "ES2019",
        "module": "commonjs",
        "rootDir": "src",
        "outDir": "dist",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "typeRoots": [
            "node_modules/@types"
        ]
    }
}

=== ŚCIEŻKA ===
src/index.ts
=== ZAWARTOŚĆ ===
import cors from 'cors';
import dotenv from 'dotenv';
import express, { Request, Response } from 'express';
import morgan from 'morgan';

import { AnnouncementController } from './controllers/AnnouncementController';
import { AuthController } from './controllers/AuthController';
import { AuthRequest, checkAuth } from './middlewares/authMiddleware';
import { checkAdmin } from './middlewares/checkAdmin';
import { checkOwnerOrAdmin } from './middlewares/checkOwnerOrAdmin';

// Load environment variables from .env file
dotenv.config();

// Initialize Express app
const app = express();

// Apply core middleware
app.use(cors()); // Enable Cross-Origin Resource Sharing (CORS)
app.use(express.json()); // Parse incoming JSON requests
app.use(morgan('dev')); // Log HTTP requests in dev-friendly format

/**
 * Healthcheck endpoint.
 * Used by monitoring tools or CI pipelines to verify that the API is online.
 */
app.get('/api/healthcheck', (req: Request, res: Response) => {
    res.json({ status: 'OK', message: 'Backend powered by Vite now!' });
});


// ---------------- AUTH ROUTES ----------------

/**
 * Register a new user (email + password).
 * Body: { email, password }
 */
app.post('/api/auth/register', AuthController.register);

/**
 * Log in an existing user and receive a JWT.
 * Body: { email, password }
 */
app.post('/api/auth/login', AuthController.login);

/**
 * Return decoded JWT for the currently authenticated user.
 * Useful for token verification and session introspection.
 */
app.get('/api/profile', checkAuth, (req: Request, res: Response) => {
    const authReq = req as AuthRequest;
    res.json({
        message: 'Dane użytkownika',
        userDecoded: authReq.user
    });
});


// ---------------- ANNOUNCEMENT ROUTES ----------------

/**
 * Publicly fetch all announcements, optionally filtered by category/type.
 */
app.get('/api/announcements', AnnouncementController.getAll);

/**
 * Public endpoint to get all distinct categories.
 * Used to dynamically populate frontend filters.
 */
app.get('/api/categories', AnnouncementController.getCategories);

/**
 * Fetch announcements created by a specific user (requires auth).
 */
app.get(
    '/api/users/:/announcements',
    checkAuth,
    AnnouncementController.getByUser
);

/**
 * Admin-only: get all announcements, with author metadata.
 */
app.get(
    '/api/admin/announcements',
    checkAuth,
    checkAdmin,
    AnnouncementController.getAllForAdmin
);

/**
 * Get current user's data (uses JWT context).
 */
app.get('/api/me', checkAuth, AnnouncementController.getMe);

/**
 * Create a new announcement (requires authentication).
 */
app.post('/api/announcements', checkAuth, AnnouncementController.create);

/**
 * Update an existing announcement.
 * Only allowed for owner or admin.
 */
app.put(
    '/api/announcements/:id',
    checkAuth,
    checkOwnerOrAdmin,
    AnnouncementController.update
);

/**
 * Delete an announcement.
 * Only allowed for owner or admin.
 */
app.delete(
    '/api/announcements/:id',
    checkAuth,
    checkOwnerOrAdmin,
    AnnouncementController.delete
);


// ---------------- SERVER INIT ----------------

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});


=== ŚCIEŻKA ===
src/controllers/AnnouncementController.ts
=== ZAWARTOŚĆ ===
import { UUID } from 'crypto';
import { Request, Response } from 'express';

import { db } from '../database/connection';
import { AuthRequest } from '../middlewares/authMiddleware';
import { AnnouncementRepository } from '../repositories/announcement/AnnouncementRepository';
import { AnnouncementService } from '../services/AnnouncementService';
import { logger } from '../utils/logger';

// Instantiate the service layer with the repository injected.
// This allows controller logic to remain thin and offload business rules to the service.
const service = new AnnouncementService(new AnnouncementRepository(db));

/**
 * Controller responsible for handling HTTP requests related to announcements.
 * Delegates all core logic to AnnouncementService and communicates results to the client.
 */
export class AnnouncementController {

    /**
     * POST /api/announcements
     * Creates a new announcement associated with the currently authenticated user.
     */
    static async create(req: AuthRequest, res: Response) {
        try {
            const { title, content, category, type } = req.body;

            if (!req.user) {
                // User must be authenticated
                return res.status(401).json({ error: 'Unauthorized' });
            }

            // Pass input to the service layer for validation and persistence
            const data = await service.create(req.user.userId, title, content, category, type);

            return res.status(201).json(data);
        } catch (e: any) {
            logger.error(e);
            return res.status(400).json({ error: e.message });
        }
    }

    /**
     * GET /api/announcements
     * Retrieves all announcements, optionally filtered by category and type.
     * No authentication required.
     */
    static async getAll(req: Request, res: Response) {
        try {
            const { category, type } = req.query as any;

            const data = await service.getAll({ category, type });

            return res.json(data);
        } catch (e) {
            logger.error(e);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }

    /**
     * GET /api/users/:id/announcements
     * Fetches all announcements created by a specific user (ID provided as URL param).
     * Requires authentication.
     */
    static async getByUser(req: Request, res: Response) {
        try {
            const data = await service.getByUser(req.params.id);
            return res.json(data);
        } catch (e) {
            logger.error(e);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }

    /**
     * GET /api/admin/announcements
     * Retrieves all announcements with author metadata (admin-only access).
     * Requires valid JWT and admin role.
     */
    static async getAllForAdmin(req: AuthRequest, res: Response) {
        try {
            const data = await service.getAllForAdmin();
            return res.json(data);
        } catch (e) {
            logger.error(e);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }

    /**
     * GET /api/categories
     * Returns a distinct list of all used categories in announcements.
     * No authentication required.
     */
    static async getCategories(_req: Request, res: Response) {
        try {
            const cats = await service.getCategories();
            return res.json(cats);
        } catch (e) {
            logger.error(e);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }

    /**
     * PUT /api/announcements/:id
     * Updates an existing announcement by ID. The request is allowed if:
     *  - The user is the announcement's owner
     *  - OR the user has admin privileges
     * Authorization logic is handled by middleware.
     */
    static async update(req: AuthRequest, res: Response) {
        const { id } = req.params;
        const { title, content, category, type } = req.body;

        try {
            const updated = await service.update(id as UUID, title, content, category, type);
            return res.status(200).json(updated);
        } catch (e) {
            const errorMessage = (e as Error).message;

            // Map domain errors to HTTP status codes
            const status = errorMessage === 'Not found'
                ? 404
                : errorMessage === 'Forbidden'
                    ? 403
                    : 400;

            return res.status(status).json({ error: errorMessage || 'An unknown error occurred' });
        }
    }

    /**
     * DELETE /api/announcements/:id
     * Deletes an announcement by ID. Permission logic is delegated to middleware:
     * Only owners or admins can delete.
     */
    static async delete(req: AuthRequest, res: Response) {
        const { id } = req.params;

        try {
            await service.delete(id as UUID);
            res.status(204).send(); // No content response
        } catch (e: any) {
            logger.error(e);
            return res.status(403).json({ error: e.message });
        }
    }

    /**
     * GET /api/me
     * Returns the decoded JWT payload of the currently authenticated user.
     * Used primarily for checking current session state on the frontend.
     */
    static async getMe(req: AuthRequest, res: Response) {
        return res.json({ user: req.user });
    }
}


=== ŚCIEŻKA ===
src/controllers/AuthController.ts
=== ZAWARTOŚĆ ===
import { Request, Response } from 'express';

import { AuthService } from '../services/AuthService';

/**
 * Controller responsible for handling authentication-related routes.
 * Delegates all business logic to the AuthService.
 */
export class AuthController {

    /**
     * POST /api/auth/register
     * Handles user registration.
     * Expects a JSON body with `email` and `password`.
     * Validates the input and delegates to the AuthService.
     */
    static async register(req: Request, res: Response) {
        try {
            const { email, password } = req.body;

            // Basic input validation
            if (!email || !password) {
                return res
                    .status(400)
                    .json({ message: 'Email and password are required' });
            }

            // Calls service method that hashes the password and inserts the new user
            const user = await AuthService.registerUser(email, password);

            // Respond with 201 Created and user data (id + email)
            return res.status(201).json(user);

        } catch (error: any) {
            // Specific error if the user already exists
            if (error.message === 'User already exists') {
                return res.status(409).json({ message: 'User already exists' });
            }

            // Generic fallback error
            console.error(error);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }

    /**
     * POST /api/auth/login
     * Handles user login.
     * Verifies email/password and returns a JWT if credentials are valid.
     */
    static async login(req: Request, res: Response) {
        try {
            const { email, password } = req.body;

            // Basic input validation
            if (!email || !password) {
                return res
                    .status(400)
                    .json({ message: 'Email and password are required' });
            }

            // Calls service method that checks credentials and returns JWT + user info
            const result = await AuthService.loginUser(email, password);

            return res.status(200).json(result);

        } catch (error: any) {
            // Invalid credentials are treated as a 401 Unauthorized
            if (error.message === 'Invalid credentials') {
                return res
                    .status(401)
                    .json({ message: 'Invalid email or password' });
            }

            // Fallback for unexpected issues
            console.error(error);
            return res.status(500).json({ message: 'Internal server error' });
        }
    }
}


=== ŚCIEŻKA ===
src/database/connection.ts
=== ZAWARTOŚĆ ===
import dotenv from 'dotenv';
import { Kysely, PostgresDialect } from 'kysely';
import { Pool } from 'pg';

dotenv.config();

export interface Database {
    users: UsersTable;
    announcements: AnnouncementTable;
}

export interface UsersTable {
    id: string;
    email: string;
    password: string;
    role: 'user' | 'admin';
}

export interface AnnouncementTable {
    id: string;
    userId: string;
    title: string;
    content: string;
    category: string;
    type: string;
    createdAt: Date;
}

export const db = new Kysely<Database>({
    dialect: new PostgresDialect({
        pool: new Pool({
            host: process.env.DB_HOST || 'localhost',
            port: Number(process.env.DB_PORT) || 5434,
            user: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'root',
            database: process.env.DB_NAME || 'somsiad'
        })
    })
});


=== ŚCIEŻKA ===
src/database/migrate.ts
=== ZAWARTOŚĆ ===
import { promises as fs } from 'fs';
import { FileMigrationProvider, Migrator } from 'kysely';
import { run } from 'kysely-migration-cli';
import * as path from 'path';

import { db } from './connection';

const migrationFolder = path.join(__dirname, 'migrations');

const migrator = new Migrator({
    db,
    provider: new FileMigrationProvider({
        fs,
        path,
        migrationFolder
    })
});

run(db, migrator, migrationFolder);


=== ŚCIEŻKA ===
src/database/migrations/initial.ts
=== ZAWARTOŚĆ ===
import bcrypt from 'bcrypt';
// For dev
import { randomUUID } from 'crypto';
import { Kysely, sql } from 'kysely';

import { Database } from '../connection';

export async function up(db: Kysely<Database>): Promise<void> {
    await db.schema
        .createTable('users')
        .addColumn('id', 'varchar(36)', column => column.primaryKey())
        .addColumn('email', 'varchar(256)', column => column.notNull())
        .addColumn('password', 'varchar(60)', column => column.notNull())
        .addColumn('role', 'varchar(5)', column =>
            column.notNull().check(sql`role IN ('user', 'admin')`)
        )
        .execute();

    // For dev
    await db
        .insertInto('users')
        .values({
            id: randomUUID(),
            email: 'yakui@example.com',
            password: await bcrypt.hash('themaid', 10),
            role: 'admin'
        })
        .execute();

    await db.schema
        .createTable('announcements')
        .addColumn('id', 'varchar(36)', column => column.primaryKey())
        .addColumn('userId', 'varchar(36)', column =>
            column
                .notNull()
                .references('users.id')
                .onUpdate('cascade')
                .onDelete('cascade')
        )
        .addColumn('title', 'varchar(256)', column => column.notNull())
        .addColumn('content', 'varchar(256)', column => column.notNull())
        .addColumn('category', 'varchar(256)', column => column.notNull())
        .addColumn('type', 'varchar(256)', column => column.notNull())
        .addColumn('createdAt', 'timestamptz', column => column.notNull())
        .execute();
}

export async function down(db: Kysely<Database>): Promise<void> {
    await db.schema.dropTable('announcements').execute();
    await db.schema.dropTable('users').execute();
}


=== ŚCIEŻKA ===
src/middlewares/authMiddleware.ts
=== ZAWARTOŚĆ ===
import dotenv from 'dotenv';
import { NextFunction, Request, Response } from 'express';
import jwt from 'jsonwebtoken';

// Load environment variables from .env file into process.env
dotenv.config();

// Fallback to a default value if JWT_SECRET is not defined (recommended to override in production)
const JWT_SECRET = process.env.JWT_SECRET || 'defaultSecret';

/**
 * Extended Request interface to include a `user` property.
 * This is populated during JWT verification and consumed by downstream middleware/controllers.
 */
export interface AuthRequest extends Request {
    user?: {
        userId: string;
        role: 'user' | 'admin';
        iat: number; // Issued At timestamp (from JWT)
        exp: number; // Expiration timestamp (from JWT)
    };
}

/**
 * Middleware to validate JWT token from the Authorization header.
 * Ensures that only authenticated users can access protected routes.
 * 
 * Expected header format:
 *   Authorization: Bearer <token>
 */
export function checkAuth(req: AuthRequest, res: Response, next: NextFunction) {
    try {
        const authHeader = req.headers.authorization;

        // Authorization header must be present
        if (!authHeader) {
            return res.status(401).json({ message: 'No token provided' });
        }

        // Token is expected to follow the "Bearer <token>" format
        const token = authHeader.split(' ')[1];
        if (!token) {
            return res.status(401).json({ message: 'Invalid token format' });
        }

        // Validate the token using the secret. If invalid, an exception will be thrown.
        const decoded = jwt.verify(token, JWT_SECRET) as AuthRequest['user'];

        // Store the decoded token data (userId, role, etc.) on the request object for later use
        req.user = decoded;

        // Pass control to the next middleware or route handler
        next();
    } catch (error) {
        // Token verification failed or was malformed
        return res.status(401).json({ message: 'Unauthorized' });
    }
}


=== ŚCIEŻKA ===
src/middlewares/checkAdmin.ts
=== ZAWARTOŚĆ ===
import { Response, NextFunction } from 'express';
import { AuthRequest } from './authMiddleware';

/**
 * Middleware to restrict access to administrator-only routes.
 * Requires that `checkAuth` has already run, and `req.user` is populated.
 * 
 * This is typically used after authentication middleware in route chains, e.g.:
 *   app.get('/admin/dashboard', checkAuth, checkAdmin, handler);
 */
export function checkAdmin(req: AuthRequest, res: Response, next: NextFunction) {
    // Check if the authenticated user has the 'admin' role
    if (req.user?.role !== 'admin') {
        // Respond with 403 Forbidden if the user is not an admin
        return res.status(403).json({ message: 'Forbidden' });
    }

    // Proceed to the next middleware or route handler
    next();
}


=== ŚCIEŻKA ===
src/middlewares/checkOwnerOrAdmin.ts
=== ZAWARTOŚĆ ===
import { NextFunction, Response } from 'express';
import { AuthRequest } from './authMiddleware';
import { logger } from '../utils/logger';

/**
 * Middleware to ensure that the authenticated user is either:
 *   - the owner of the resource (e.g., owns the announcement or user profile),
 *   - or has the 'admin' role.
 * 
 * This is typically used for update/delete actions on resources tied to a specific user ID.
 * It should always be used after the `checkAuth` middleware, which populates `req.user`.
 */
export function checkOwnerOrAdmin(
    req: AuthRequest,
    res: Response,
    next: NextFunction
) {
    // Reject request if no authenticated user is found (shouldn't happen if `checkAuth` ran)
    if (!req.user) {
        return res.status(401).json({ message: 'Unauthorized: missing user' });
    }

    const { userId, role } = req.user;

    /**
     * Determine the "target" userId that the action is attempting to access or modify.
     * This ID might come from the request body (e.g., on update) or the route parameters.
     */
    const targetUserId = req.body.userId || req.params.userId;

    /**
     * If the authenticated user is neither the owner of the resource
     * nor an admin, reject with a 403 Forbidden.
     */
    if (userId !== targetUserId && role !== 'admin') {
        logger.error(`Forbidden: ${userId} tried to access ${targetUserId}`);
        return res.status(403).json({ message: 'Forbidden' });
    }

    // User is either the owner or an admin — allow the request to proceed
    next();
}


=== ŚCIEŻKA ===
src/models/Announcement.ts
=== ZAWARTOŚĆ ===
import { UUID } from 'crypto';

/**
 * Domain model representing an announcement (post/ad).
 * Encapsulates the internal state of an announcement and provides accessors for controlled read access.
 *
 * This class serves as a plain domain object (not tied to persistence logic),
 * and is typically instantiated in the repository and returned to service/controller layers.
 */
export class Announcement {
    constructor(
        /** Unique identifier of the announcement (UUID v4) */
        readonly id: UUID,

        /** UUID of the user who created the announcement */
        readonly userId: UUID,

        /** Title of the announcement (e.g., "Bike for sale") */
        private title: string,

        /** Main content/body of the announcement */
        private content: string,

        /** Category label (e.g., "electronics", "services", "misc") */
        private category: string,

        /** Type label (e.g., "offer", "request") */
        private type: string,

        /** Creation timestamp (set when announcement is created) */
        readonly createdAt: Date
    ) { }

    // Accessor methods to expose private fields in a controlled manner

    getTitle(): string {
        return this.title;
    }

    getContent(): string {
        return this.content;
    }

    getCategory(): string {
        return this.category;
    }

    getType(): string {
        return this.type;
    }
}


=== ŚCIEŻKA ===
src/models/User.ts
=== ZAWARTOŚĆ ===
import { UUID } from 'crypto';

/**
 * Domain model representing an application user.
 * Encapsulates the core properties and accessors related to authentication and authorization.
 *
 * This class is a plain domain object — not directly coupled to any framework or persistence logic.
 * It is used across repositories, services, and sometimes controllers for typed business logic.
 */
export class User {
    constructor(
        /** Unique identifier of the user (UUID v4) */
        readonly id: UUID,

        /** Email address used for authentication and communication */
        private email: string,

        /** Hashed password (never stored or returned in raw form) */
        private password: string,

        /** Role-based access control flag — determines user privileges */
        private role: 'user' | 'admin'
    ) { }

    // Getter for the email address (used in token payloads, profile views, etc.)
    getEmail(): string {
        return this.email;
    }

    // Getter for the hashed password (used for credential comparison during login)
    getPassword(): string {
        return this.password;
    }

    // Getter for the role (used in middleware and admin-level checks)
    getRole(): 'user' | 'admin' {
        return this.role;
    }
}


=== ŚCIEŻKA ===
src/repositories/announcement/AnnouncementRepository.ts
=== ZAWARTOŚĆ ===
import { randomUUID, UUID } from 'crypto';
import { Kysely } from 'kysely';
import { sql } from 'kysely';

import { Database } from '../../database/connection';
import { Announcement } from '../../models/Announcement';

/**
 * Repository responsible for accessing and modifying announcement-related data.
 * This class interacts directly with the database and returns domain models (not raw DB rows).
 * 
 * By separating data access from business logic, we maintain clean architecture and testability.
 */
export class AnnouncementRepository {
    constructor(private db: Kysely<Database>) { }

    /**
     * Returns all announcements in the system without filtering.
     * Used mostly for testing or internal/admin use.
     */
    async getAllAnnouncements(): Promise<Announcement[]> {
        const result = await this.db
            .selectFrom('announcements')
            .selectAll()
            .execute();

        return result.map(r => new Announcement(
            r.id as UUID,
            r.userId as UUID,
            r.title,
            r.content,
            r.category,
            r.type,
            r.createdAt
        ));
    }

    /**
     * Returns all announcements created by a specific user.
     * @param userId - the UUID of the user
     */
    async getAnnouncementsByUserId(userId: UUID): Promise<Announcement[]> {
        const result = await this.db
            .selectFrom('announcements')
            .selectAll()
            .where('userId', '=', userId)
            .execute();

        return result.map(r => new Announcement(
            r.id as UUID,
            r.userId as UUID,
            r.title,
            r.content,
            r.category,
            r.type,
            r.createdAt
        ));
    }

    /**
     * Inserts a new announcement into the database.
     * Generates a new UUID and creation timestamp on insert.
     */
    async addAnnouncement(
        userId: UUID,
        title: string,
        content: string,
        category: string,
        type: string
    ): Promise<Announcement> {
        const newAnnouncement = new Announcement(
            randomUUID(),
            userId,
            title,
            content,
            category,
            type,
            new Date()
        );

        // Insert the record into the DB
        await this.db
            .insertInto('announcements')
            .values({
                id: newAnnouncement.id,
                userId: newAnnouncement.userId,
                title: newAnnouncement.getTitle(),
                content: newAnnouncement.getContent(),
                category: newAnnouncement.getCategory(),
                type: newAnnouncement.getType(),
                createdAt: newAnnouncement.createdAt
            })
            .execute();

        return newAnnouncement;
    }

    /**
     * Updates an existing announcement.
     * Returns the updated domain object if found; otherwise, returns null.
     */
    async updateAnnouncement(
        id: UUID,
        title: string,
        content: string,
        category: string,
        type: string
    ): Promise<Announcement | null> {
        const row = await this.db
            .updateTable('announcements')
            .set({
                title,
                content,
                category,
                type
            })
            .where('id', '=', id)
            .returningAll()
            .executeTakeFirst();

        if (!row) return null;

        return new Announcement(
            row.id as UUID,
            row.userId as UUID,
            row.title,
            row.content,
            row.category,
            row.type,
            row.createdAt
        );
    }

    /**
     * Deletes an announcement by ID.
     */
    async deleteAnnouncement(id: UUID): Promise<void> {
        await this.db
            .deleteFrom('announcements')
            .where('id', '=', id)
            .execute();
    }

    /**
     * Returns announcements filtered by optional category and/or type.
     */
    async getFiltered(category?: string, type?: string): Promise<Announcement[]> {
        let qb = this.db.selectFrom('announcements').selectAll();

        if (category) qb = qb.where('category', '=', category);
        if (type) qb = qb.where('type', '=', type);

        const result = await qb.execute();

        return result.map(r => new Announcement(
            r.id as UUID,
            r.userId as UUID,
            r.title,
            r.content,
            r.category,
            r.type,
            r.createdAt
        ));
    }

    /**
     * Returns all announcements joined with author data (email).
     * Used in admin views to associate posts with user accounts.
     */
    async getAllWithAuthors() {
        const rows = await this.db
            .selectFrom('announcements as a')
            .innerJoin('users as u', 'a.userId', 'u.id')
            .select([
                'a.id',
                'a.title',
                'a.content',
                'a.category',
                'a.type',
                'a.createdAt',
                'u.id as userId',
                'u.email as authorEmail'
            ])
            .execute();

        return rows.map(r => ({
            id: r.id,
            title: r.title,
            content: r.content,
            category: r.category,
            type: r.type,
            createdAt: r.createdAt,
            userId: r.userId,
            authorEmail: r.authorEmail
        }));
    }

    /**
     * Returns a list of all distinct categories currently used in announcements.
     * Useful for building dynamic filters on the frontend.
     */
    async getDistinctCategories(): Promise<string[]> {
        const rows = await this.db
            .selectFrom('announcements')
            .select(sql`distinct category`.as('category'))
            .execute();

        return rows.map(r => r.category as string);
    }
}


=== ŚCIEŻKA ===
src/repositories/user/UserRepository.ts
=== ZAWARTOŚĆ ===
import { randomUUID, UUID } from 'crypto';
import { Kysely } from 'kysely';

import { Database } from '../../database/connection';
import { User } from '../../models/User';

/**
 * Repository class responsible for direct interaction with the `users` table.
 * Encapsulates all SQL-related logic for creating and retrieving user data.
 * Returns domain objects (User instances) rather than raw query results.
 */
export class UserRepository {
    constructor(private db: Kysely<Database>) { }

    /**
     * Adds a new user to the database.
     * Generates a UUID server-side and accepts a hashed password.
     *
     * @param email - The user’s email address
     * @param password - Hashed password (never raw text)
     * @param role - The role assigned to the user ('user' or 'admin')
     * @returns A User domain model instance representing the newly created user
     */
    async addUser(
        email: string,
        password: string,
        role: 'user' | 'admin'
    ): Promise<User> {
        const newUser = new User(randomUUID(), email, password, role);

        await this.db
            .insertInto('users')
            .values({
                id: newUser.id,
                email: newUser.getEmail(),
                password: newUser.getPassword(),
                role: newUser.getRole()
            })
            .execute();

        return newUser;
    }

    /**
     * Fetches a user by their email address.
     * This is used during login to retrieve the hashed password and verify credentials.
     *
     * @param email - The email to search for
     * @returns A User instance if found, or `null` if no user exists with that email
     */
    async getUserByEmail(email: string): Promise<User | null> {
        const result = await this.db
            .selectFrom('users')
            .selectAll()
            .where('email', '=', email)
            .execute();

        if (result.length <= 0) {
            return null;
        }

        const { id, password, role } = result[0];

        return new User(id as UUID, email, password, role);
    }
}


=== ŚCIEŻKA ===
src/services/AnnouncementService.ts
=== ZAWARTOŚĆ ===
import { UUID } from 'crypto';

import { AnnouncementRepository } from '../repositories/announcement/AnnouncementRepository';
import { logger } from '../utils/logger';

/**
 * Service layer responsible for business logic related to announcements.
 * It mediates between the controller layer (HTTP) and the repository (database access).
 *
 * This class contains validation, fallback logic, and coordinates complex operations.
 */
export class AnnouncementService {
    constructor(private repo: AnnouncementRepository) { }

    /**
     * Creates a new announcement after validating required fields.
     *
     * @param userId - UUID of the user creating the announcement
     * @param title - Announcement title (required)
     * @param content - Main body of the announcement (required)
     * @param category - Category label (required)
     * @param type - Type label (required)
     * @throws Error if any field is missing
     * @returns The created Announcement instance
     */
    async create(
        userId: string,
        title: string,
        content: string,
        category: string,
        type: string
    ) {
        if (!title || !content || !category || !type) {
            throw new Error('All fields are required');
        }

        return this.repo.addAnnouncement(userId as UUID, title, content, category, type);
    }

    /**
     * Retrieves all announcements, optionally filtered by category and/or type.
     *
     * @param filters - Optional category and type filters
     * @returns List of matching Announcement instances
     */
    async getAll(filters: { category?: string; type?: string }) {
        return this.repo.getFiltered(filters.category, filters.type);
    }

    /**
     * Retrieves all announcements created by a specific user.
     *
     * @param userId - UUID of the user
     * @returns List of that user's announcements
     */
    async getByUser(userId: string) {
        return this.repo.getAnnouncementsByUserId(userId as UUID);
    }

    /**
     * Retrieves all announcements along with author email metadata.
     * Intended for administrative views only.
     */
    async getAllForAdmin() {
        return this.repo.getAllWithAuthors();
    }

    /**
     * Retrieves all unique announcement categories.
     * Used to populate dropdown filters on the frontend.
     */
    async getCategories() {
        return this.repo.getDistinctCategories();
    }

    /**
     * Updates an existing announcement.
     * 
     * @param id - ID of the announcement to update
     * @param title - New title
     * @param content - New content
     * @param category - New category
     * @param type - New type
     * @throws Error if no announcement was found for the given ID
     * @returns The updated Announcement
     */
    async update(
        id: UUID,
        title: string,
        content: string,
        category: string,
        type: string
    ) {
        const updated = await this.repo.updateAnnouncement(id, title, content, category, type);
        if (!updated) {
            throw new Error('Not found');
        }
        return updated;
    }

    /**
     * Deletes an announcement by ID.
     * 
     * @param id - UUID of the announcement
     * @returns Promise that resolves when deletion is complete
     */
    delete(id: UUID) {
        return this.repo.deleteAnnouncement(id);
    }
}


=== ŚCIEŻKA ===
src/services/AuthService.ts
=== ZAWARTOŚĆ ===
import bcrypt from 'bcrypt';
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';

import { db } from '../database/connection';
import { UserRepository } from '../repositories/user/UserRepository';

dotenv.config();

// Fallback used if JWT_SECRET is not provided in .env (should be overridden in production)
const JWT_SECRET = process.env.JWT_SECRET || 'defaultSecret';

// Repository instance for handling user persistence
const userRepo = new UserRepository(db);

/**
 * Service layer responsible for authentication logic:
 * - Account creation (registration)
 * - Credential validation (login)
 * - Password hashing
 * - Token generation (JWT)
 */
export class AuthService {

    /**
     * Registers a new user account after validating email uniqueness and hashing the password.
     *
     * @param email - The user’s email address
     * @param plainPassword - The raw password input from the user
     * @throws Error if the email is already in use
     * @returns A lightweight object with the new user's ID and email
     */
    static async registerUser(email: string, plainPassword: string) {
        // Prevent duplicate registration
        const existingUser = await userRepo.getUserByEmail(email);
        if (existingUser) {
            throw new Error('User already exists');
        }

        // Hash the password with bcrypt
        const saltRounds = 10;
        const hashedPassword = await bcrypt.hash(plainPassword, saltRounds);

        // Create a new user with default 'user' role
        const newUser = await userRepo.addUser(email, hashedPassword, 'user');

        // Return minimal public-safe data
        return { id: newUser.id, email: newUser.getEmail() };
    }

    /**
     * Validates credentials and issues a signed JWT if valid.
     *
     * @param email - Email address entered during login
     * @param plainPassword - Raw password entered by the user
     * @throws Error if the credentials are invalid
     * @returns An object containing a JWT and user information
     */
    static async loginUser(email: string, plainPassword: string) {
        const user = await userRepo.getUserByEmail(email);
        if (!user) {
            throw new Error('Invalid credentials');
        }

        // Compare provided password with stored hash
        const isMatch = await bcrypt.compare(plainPassword, user.getPassword());
        if (!isMatch) {
            throw new Error('Invalid credentials');
        }

        // Generate JWT with user ID and role as payload
        const token = jwt.sign(
            {
                userId: user.id,
                role: user.getRole()
            },
            JWT_SECRET,
            { expiresIn: process.env.JWT_EXPIRES_IN || '1h' }
        );

        // Return token and limited user data
        return {
            token,
            user: {
                id: user.id,
                email: user.getEmail(),
                role: user.getRole()
            }
        };
    }
}


=== ŚCIEŻKA ===
src/utils/logger.ts
=== ZAWARTOŚĆ ===
import { createLogger, format, transports } from 'winston';
import path from 'path';

/**
 * Application-wide logger instance configured with Winston.
 * Currently logs only errors to a file (`logs/error.log`) in timestamped, structured format.
 *
 * This logger can be extended with additional levels (info, warn, debug)
 * and transports (e.g., console, external services) as the app evolves.
 */
export const logger = createLogger({
    // Only messages with level 'error' or more severe will be logged
    level: 'error',

    // Define the output format
    format: format.combine(
        format.timestamp(), // Add ISO-formatted timestamp to each log entry
        format.errors({ stack: true }), // Ensure full stack traces are included for error objects
        format.printf(({ timestamp, level, message, stack }) =>
            `${timestamp} ${level}: ${stack || message}` // Custom log message format
        )
    ),

    // Define log destinations (transports)
    transports: [
        // Log error messages to 'logs/error.log' file
        new transports.File({ filename: path.join('logs', 'error.log') })
    ]
});


